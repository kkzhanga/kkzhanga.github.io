{"meta":{"title":"KKZhang’s Blog","subtitle":"","description":"","author":"kkzhang","url":"https://kkzhanga.github.io","root":"/"},"pages":[],"posts":[{"title":"springBoot自定义starter","slug":"springBoot/starter1","date":"2021-04-22T08:43:07.000Z","updated":"2021-04-26T07:19:40.546Z","comments":true,"path":"2021/04/22/springBoot/starter1/","link":"","permalink":"https://kkzhanga.github.io/2021/04/22/springBoot/starter1/","excerpt":"","text":"前言 一直想总结下springBoot的starter机制，以便于对自动装配能有进一步的了解。使用starter之前，需要了解下SPI机制。 SPI机制SPI机制介绍 SPI全称Service Provider Interface(服务提供发现机制)， 是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是: 解耦。 如图所示： 例子： JDK中有支持音乐播放，假设只支持mp3的播放，有些厂商想在这个基础之上支持mp4播放，有的想支持mp5播放， 而这些厂商都是第三方厂商，如果没有提供SPI这种实现标准，那就只有修改JAVA的源代码了，那这个弊端也是显而易见的，而有了SPI标准，SUN公司只需要提供一个播放接口，在实现播放的功能上通过ServiceLoad的方式加载服务，那么第三方只需要实现这个播放接口，再按SPI标准的约定进行打包，再放到classpath下面就OK了，没有一点代码的侵入性。 SPI约定 1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名(接口全路径是com.kk.test,那么文件名也是com.kk.test)； 2、接口实现类所在的jar包放在主程序的classpath中； 3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM； 4、SPI的实现类必须携带一个不带参数的构造方法； SPI应用场景 JDBC加载不同类型数据库的驱动 日志门面接口实现类加载，SLF4J对log4j/logback的支持 Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等 Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口 starter机制 在我们的日常开发工作中，一些独立于业务之外的配置模块，我们将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，需要将代码硬拷贝到另一个工程，重新集成一遍，麻烦至极。如果我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可，SpringBoot为我们完成自动装配。 这时会有一个疑问，难倒不可以将复用功能打成了一个jar包，deploy到了你们公司的maven仓库里，然后依赖不就行了吗？这样做当然也是可以的，但如果jar包路径跟项目本身包路径不完全一致，为了让他代码里的一些bean可以注入到IOC容器，你就需要在你们的项目里通过@ComponentScan注解指定要扫描的包路径也包括他们的。。。。如果复用的jar多起来，就会导致非常的繁琐。 starter的意义 SpringBoot中的starter是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。SpringBoot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。 starter的命名规则SpringBoot提供的starter以spring-boot-starter-xxx的方式命名的。官方建议自定义的starter使用xxx-spring-boot-starter命名规则。以区分SpringBoot生态提供的starter。 starter的应用场景 在平常遇到的一些场景。 网关 日志跟踪 mqtt 报文加密 推流 。。。。 自定义starter 新建starter工程，参照先前的博客 资源目录resources下建立一个 META-INF 目录，并在该目录下建立一个 spring.factories 文件，指定你要被IOC容器管理的配置类的全额限定名(命名方式都为：XXXXAutoConfiguration —&gt;即自动配置类) 在starter工程中执行mvn clean install 一个自定义的starter完成。 starter加载流程","categories":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/categories/springBoot/"}],"tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/tags/springBoot/"},{"name":"starter","slug":"starter","permalink":"https://kkzhanga.github.io/tags/starter/"},{"name":"spi","slug":"spi","permalink":"https://kkzhanga.github.io/tags/spi/"}]},{"title":"springBoot之过滤器 vs 拦截器","slug":"spring/filterAndInterceptor","date":"2020-12-11T08:43:07.000Z","updated":"2020-12-14T12:18:20.871Z","comments":true,"path":"2020/12/11/spring/filterAndInterceptor/","link":"","permalink":"https://kkzhanga.github.io/2020/12/11/spring/filterAndInterceptor/","excerpt":"对于过滤器和拦截器只是使用，没有仔细了解二者的区别，这次写个博客好好总结一下。","text":"对于过滤器和拦截器只是使用，没有仔细了解二者的区别，这次写个博客好好总结一下。 过滤器过滤器Filter，是在Servlet规范中定义的，是Servlet容器支持的，该接口定义在 javax.servlet包下，主要是在客户端请求(HttpServletRequest)进行预处理，以及对服务器响应(HttpServletResponse)进行后处理 自定义过滤器 Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;a&quot;)public class AFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; //初始化接口,服务启动的时候加载 System.out.println(&quot;init1执行&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; /** 在每个用户的请求进来时这个方法都会被调用，并在Servlet的service方法之前调用(如果我们是开发Servlet项目)，而FilterChain就代表当前的整个请求链， * 通过调用 FilterChain.doFilter可以将请求继续传递下去，如果想拦截这个请求，可以不调用FilterChain.doFilter，那么这个请求就直接返回了， * 所以Filter是一种责任链设计模式，在spring security就大量使用了过滤器，有一条过滤器链。*/ System.out.println(&quot;doFilter1执行&quot;); long start = System.currentTimeMillis(); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;Filter1 cost=&quot; + (System.currentTimeMillis() - start)); &#125; @Override public void destroy() &#123; //当Filter对象被销毁时(优雅停服)被调用，注意当Web容器调用这个方法之后，容器会再调用一次doFilter方法 System.out.println(&quot;destroy1执行&quot;); &#125;&#125;@SpringBootApplication@EnableDiscoveryClient@ServletComponentScan(value = &#123;&quot;com.kk.zhang.filter&quot;&#125;)//指定扫描自定义过滤器所在包public class OrderApp &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext ctx = SpringApplication.run(OrderApp.class, args); //停服 /* try &#123; TimeUnit.SECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ctx.close();*/ &#125;&#125; 除了上述自定义过滤器方式，还有一种就是FilterRegistrationBean来完成配置。如果自定义多个过滤器如何排序呢？@WebFilter这个注解并没有指定执行顺序的属性，其执行顺序依赖于Filter的名称，是根据Filter类名（注意不是配置的filter的名字）的字母顺序倒序排列，并且@WebFilter指定的过滤器优先级都高于FilterRegistrationBean配置的过滤器。 拦截器拦截器是Spring提出的概念，它的作用于过滤器类似，可以拦截用户请求并进行相应的处理，它可以进行更加精细的控制。在SpringMVC中，DispatcherServlet捕获每个请求，在到达对应的Controller之前，请求可以被拦截器处理，在拦截器中进行前置处理后，请求最终才到达Controller。 自定义拦截器 Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AInterceptor implements HandlerInterceptor &#123; long start = System.currentTimeMillis(); @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; //对客户端发过来的请求进行前置处理，如果方法返回true,继续执行后续操作，如果返回false，执行中断请求处理，请求不会发送到Controller start = System.currentTimeMillis(); System.out.println(&quot;preHandle1&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; //在请求进行处理后执行，也就是在Controller方法调用之后处理，当然前提是之前的 preHandle方法返回 true。具体来说， // postHandler方法会在DispatcherServlet进行视图返回渲染前被调用，也就是说我们可以在这个方法中对 Controller 处理之后的ModelAndView对象进行操作 System.out.println(&quot;postHandle1 cost=&quot;+(System.currentTimeMillis()-start)); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; //该方法在整个请求结束之后执行，当然前提依然是 preHandle方法的返回值为 true才行。该方法一般用于资源清理工作 System.out.println(&quot;afterCompletion1&quot;); &#125;&#125;@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //实现多个拦截器，并依次将他们注册进去 registry.addInterceptor(handlerInterceptorA()) .addPathPatterns(&quot;/**&quot;); //配置拦截规则 registry.addInterceptor(handlerInterceptorB()) .addPathPatterns(&quot;/**&quot;); //配置拦截规则 &#125; @Bean public HandlerInterceptor handlerInterceptorA() &#123; return new AInterceptor(); &#125; @Bean public HandlerInterceptor handlerInterceptorB() &#123; return new BInterceptor(); &#125;&#125; 拦截器的顺序跟他们注册时的顺序有关，下图表示了两个拦截器协同工作时的执行顺序： 执行顺序过滤器init -&gt; 过滤器doFilter -&gt; 拦截器preHandle -&gt; aop -&gt; 业务逻辑 -&gt; 拦截器postHandle -&gt; 拦截器afterCompletion -&gt; 过滤器destroy 测试结果： Java 1234567891011doFilter1执行doFilter2执行preHandle1preHandle2业务postHandle2 cost=1postHandle1 cost=1afterCompletion2afterCompletion1Filter2 cost=5Filter1 cost=5 区别从上面对拦截器与过滤器的描述来看，它俩是非常相似的，都能对客户端发来的请求进行处理，它们的区别如下： 作用域不同 过滤器依赖于servlet容器，基于函数回调，对所有请求起作用拦截器依赖于spring容器，基于反射，对action请求起作用 细粒度的不同 过滤器的控制比较粗，只能在请求进来时进行处理，对请求和响应进行包装拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，也可以在渲染视图呈现给用户之后调用 中断链执行的难易程度不同 拦截器可以 preHandle方法内返回 false 进行中断过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面 应用场景 过滤器的应用：字符编码转换，敏感词过滤、登陆权限验证、资源访问权限等 拦截器的应用：AOP、需要有一些业务逻辑（需要注入Bean等）","categories":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/categories/springBoot/"}],"tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/tags/springBoot/"},{"name":"filter","slug":"filter","permalink":"https://kkzhanga.github.io/tags/filter/"},{"name":"interceptor","slug":"interceptor","permalink":"https://kkzhanga.github.io/tags/interceptor/"}]},{"title":"从零搭建sprinCloud框架（三）","slug":"springCloud/buildSprinCloud_3","date":"2020-11-27T06:16:20.000Z","updated":"2020-12-10T09:44:58.124Z","comments":true,"path":"2020/11/27/springCloud/buildSprinCloud_3/","link":"","permalink":"https://kkzhanga.github.io/2020/11/27/springCloud/buildSprinCloud_3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"从零搭建sprinCloud框架（二）","slug":"springCloud/buildSprinCloud_2","date":"2020-11-26T06:16:20.000Z","updated":"2020-12-10T10:40:47.746Z","comments":true,"path":"2020/11/26/springCloud/buildSprinCloud_2/","link":"","permalink":"https://kkzhanga.github.io/2020/11/26/springCloud/buildSprinCloud_2/","excerpt":"整合gateway简介SpringCloud Gateway成为SpringCloud的重要组件是为了提到替代Netflix Zuul(1.x版本基于过滤器，阻塞IO，不支持长连接，2.x版本一直跳票，2019年5月，开源了支持异步调用模式的Zuul 2.0版本)","text":"整合gateway简介SpringCloud Gateway成为SpringCloud的重要组件是为了提到替代Netflix Zuul(1.x版本基于过滤器，阻塞IO，不支持长连接，2.x版本一直跳票，2019年5月，开源了支持异步调用模式的Zuul 2.0版本) 功能 动态路由 限流 跨域 鉴权，黑白名单机制 日志记录 动态路由Gateway与Eureka整合原理：网关根据serviceId自动从注册中心获取服务地址并转发请求 新建eureka微服务： YML 123456789101112131415#当前服务名称spring: application: name: eureka-service#端口,路径server: port: 10002eureka: client: register-with-eureka: false #自身 不在向eureka注册 fetch-registry: false #启动时禁用client的注册 service-url: defaultZone: http://localhost:10002/eureka POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Java 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaApp&#123; public static void main( String[] args ) &#123; SpringApplication.run(EurekaApp.class,args); &#125;&#125; 新建gateway微服务： YML 12345678910111213141516171819202122232425#当前服务名称spring: application: name: gateway-server cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后#端口,路径server: port: 11111# 配置 Eureka Server 注册中心eureka: client: service-url: defaultZone: http://localhost:10002/eureka XML 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; Java 123456789@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApp&#123; public static void main( String[] args ) &#123; SpringApplication.run(GatewayApp.class,args); &#125;&#125; 新建order微服务： 根据上面示例创建两个端口不同，名称一致的微服务提供者，模拟集群多示例（略）。 验证 打开eureka控制台我们就可以看到order已经有了两个实例，通过多次点击查询，返回不同实例值。证明达到了负载均衡的效果(eureka集成了ribbon，默认使用的负载均衡策略是轮询，待后续研究) 限流限流背景 业务发展迅速 恶意请求，瞬间并发 限流规则 依赖： POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 限流参数： YML 123456789101112131415161718192021222324spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - name: RequestRateLimiter # 限流过滤器 args: redis-rate-limiter.replenishRate: 1 # 令牌桶每秒填充速率 redis-rate-limiter.burstCapacity: 2 # 令牌桶总容量 key-resolver: &quot;#&#123;@pathKeyResolver&#125;&quot; # 使用 SpEL 表达式按名称引用 bean filter名称必须是RequestRateLimiter redis-rate-limiter.replenishRate：允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity：令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver：使用SpEL按名称引用bean IP限流 Java 1234@Beanpublic KeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&#125; 接口限流 Java 123456@Bean public KeyResolver pathKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath()); &#125; &lt;details&gt; &lt;summary&gt;Java&lt;/summary&gt; 参数限流 Java 1234@Bean public KeyResolver parameterKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;userId&quot;)); &#125; 调试浏览器中对此点击进行接口测试，Redis中会有对应的数据： timestamp:存储的是当前时间的秒数，也就是System.currentTimeMillis() / 1000或者Instant.now().getEpochSecond() tokens:存储的是当前这秒钟的对应的可用的令牌数量 注意事项限流是根据每秒处理数，redis中数据存留的时间只有一秒钟，如果你不快点看redis中是否有数据的话，就看不到了 过滤器Spring Cloud Gateway 根据作用范围划分为 GatewayFilter(局部) 和 GlobalFilter(全局)，二者区别如下： GatewayFilter：局部过滤器，需要通过 spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过 spring.cloud.default-filters 配置在全局，作用在所有路由上。 GlobalFilter：全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过 GatewayFilterAdapter 包装成 GatewayFilterChain 可识别的过滤器，它为请求业务以及路由的 URI 转换为真实业务服务请求地址的核心过滤器，不需要配置系统初始化时加载，并作用在每个路由上。 局部过滤器网关过滤器用于拦截并链式处理 Web 请求，可以实现横切与应用无关的需求，比如：安全、访问超时的设置等。修改传入的 HTTP 请求或传出 HTTP 响应。Spring Cloud Gateway 包含许多内置的网关过滤器工厂一共有 22 个，包括头部过滤器、 路径类过滤器、Hystrix 过滤器和重写请求 URL 的过滤器， 还有参数和状态码等其他类型的过滤器。根据过滤器工厂的用途来划分，可以分为以下几种：Header、Parameter、Path、Body、Status、Session、Redirect、Retry、RateLimiter 和 Hystrix。 我们举个例子说明如何使用 Path路径过滤器 StripPrefixGatewayFilterFactory YML 1234567891011121314151617181920spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 自定义局部过滤器1、继承GatewayFilter，实现后使用java方式配置路由； 2、继承AbstractGatewayFilterFactory，注入为bean即可（推荐） 自定义局部过滤器，并且加入到过滤器工厂，注册到spring容器中 Java 12345678910111213141516171819202122232425public class PartGatewayFilter implements GatewayFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;自定义局部过滤器执行。。。&quot;); return chain.filter(exchange); &#125; /** * 过滤器执行顺序，数值越小，优先级越高 * @return */ @Override public int getOrder() &#123; return 0; &#125;&#125;@Componentpublic class PartGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt; &#123; @Override public GatewayFilter apply(Object config) &#123; return new PartGatewayFilter(); &#125;&#125; YML 123456789101112131415161718192021spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 - Part #自定义局部过滤器(配置名称取GatewayFilter前字符串) 自定义局部过滤器 - 指定IP访问我们的需求是如果在配置文件配置了一个IP，那么该ip就可以访问，其它IP通通不能访问。如果不使用该过滤器，那么所有IP都可以访问服务。 这里我们看到上面的PartGatewayFilter和PartGatewayFilterFactory代码本来就是为了同一个过滤器规则编写的两个类，如果过滤器规则很多，那么类文件就很多，其实这两个类可以合并成一个类： Java 1234567891011121314151617181920212223242526272829303132333435@Component@Order(Ordered.LOWEST_PRECEDENCE)public class IPForbidGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;IPForbidGatewayFilterFactory.Config&gt; &#123; public IPForbidGatewayFilterFactory() &#123; super(Config.class); &#125; @Override public List&lt;String&gt; shortcutFieldOrder() &#123; //集合中数据对应Config对象中属性,yml文件中IPForbid带的参数会映射上去,多个参数以逗号隔开 return Arrays.asList(&quot;ip&quot;); &#125; @Override public GatewayFilter apply(Config config) &#123; return (exchange, chain) -&gt; &#123; String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress(); if (config.ip.equals(ip)) &#123; return chain.filter(exchange); &#125; exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); return exchange.getResponse().setComplete(); &#125;; &#125; @Data static public class Config &#123; private String ip; &#125;&#125; YML 1234filters: # 网关过滤器 # - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 - Part #自定义局部过滤器(配置名称取GatewayFilter前字符串) - IPForbid=0:0:0:0:0:0:0:1 全局过滤器实现 GlobalFilter 和 Ordered，重写相关方法，加入到spring容器管理即可，无需配置，全局过滤器对所有的路由都有效。 自定义全局过滤器 接口 Java 123456789101112131415161718192021@Componentpublic class WholeGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;自定义全局过滤器执行。。。&quot;); //调用请求之前统计时间 Long startTime = System.currentTimeMillis(); return chain.filter(exchange).then().then(Mono.fromRunnable(() -&gt; &#123; //调用请求之后统计时间 Long endTime = System.currentTimeMillis(); System.out.println( exchange.getRequest().getURI().getRawPath() + &quot;, 请求耗时 : &quot; + (endTime - startTime) + &quot;ms&quot;); &#125;)); // 继续向下执行 &#125; @Override public int getOrder() &#123; return 1; &#125;&#125; 配置 Java 123456789101112131415161718@Configurationpublic class WholeGlobalFilter &#123; @Bean @Order(1) public GlobalFilter elapsedGlobalFilter() &#123; return (exchange, chain) -&gt; &#123; //调用请求之前统计时间 Long startTime = System.currentTimeMillis(); return chain.filter(exchange).then().then(Mono.fromRunnable(() -&gt; &#123; //调用请求之后统计时间 Long endTime = System.currentTimeMillis(); System.out.println( exchange.getRequest().getURI().getRawPath() + &quot;, 请求耗时 : &quot; + (endTime - startTime) + &quot;ms&quot;); &#125;)); &#125;; &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"从零搭建sprinCloud框架（一）","slug":"springCloud/buildSprinCloud_1","date":"2020-11-19T08:43:07.000Z","updated":"2020-12-10T08:16:04.115Z","comments":true,"path":"2020/11/19/springCloud/buildSprinCloud_1/","link":"","permalink":"https://kkzhanga.github.io/2020/11/19/springCloud/buildSprinCloud_1/","excerpt":"搭建工程基础框架项目父工程配置Idea创建工程： File -&gt; New -&gt; Project","text":"搭建工程基础框架项目父工程配置Idea创建工程： File -&gt; New -&gt; Project Empty Project -&gt;Next 项目命名 -&gt; 项目位置-&gt; Finish 选择打开新窗口 项目子工程配置配置Maven File -&gt; Settings -&gt; OK 新建Module文件 项目上右击 -&gt; New -&gt; Module 选择java -&gt; Next 设置中台模块名称 其他同级模块新建同理，比如前台，docs，sql等，最终呈现如图所示： 新建maven项目 项目上右击(如middle) -&gt; New -&gt; Module -&gt; Maven -&gt; quickstart -&gt;Next 设置ArtifactId，groupId为组织名，一般为公司网址反写 -&gt; Next 设置工程名称(在根目录下新加同名子文件夹) -&gt; Finish 创建resources文件夹: 右击main -&gt; New -&gt; Directory 右击resources, 变成有黄色的横杠,作为资源根目录","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/tags/SpringCloud/"},{"name":"maven","slug":"maven","permalink":"https://kkzhanga.github.io/tags/maven/"},{"name":"idea","slug":"idea","permalink":"https://kkzhanga.github.io/tags/idea/"}]}],"categories":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/categories/springBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/tags/springBoot/"},{"name":"starter","slug":"starter","permalink":"https://kkzhanga.github.io/tags/starter/"},{"name":"spi","slug":"spi","permalink":"https://kkzhanga.github.io/tags/spi/"},{"name":"filter","slug":"filter","permalink":"https://kkzhanga.github.io/tags/filter/"},{"name":"interceptor","slug":"interceptor","permalink":"https://kkzhanga.github.io/tags/interceptor/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/tags/SpringCloud/"},{"name":"maven","slug":"maven","permalink":"https://kkzhanga.github.io/tags/maven/"},{"name":"idea","slug":"idea","permalink":"https://kkzhanga.github.io/tags/idea/"}]}