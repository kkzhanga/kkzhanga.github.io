{"meta":{"title":"KKZhang’s Blog","subtitle":"","description":"","author":"kkzhang","url":"https://kkzhanga.github.io","root":"/"},"pages":[],"posts":[{"title":"springBoot之过滤器 vs 拦截器","slug":"spring/filterAndInterceptor","date":"2020-12-11T08:43:07.000Z","updated":"2020-12-11T08:30:48.934Z","comments":true,"path":"2020/12/11/spring/filterAndInterceptor/","link":"","permalink":"https://kkzhanga.github.io/2020/12/11/spring/filterAndInterceptor/","excerpt":"","text":"从上面对拦截器与过滤器的描述来看，它俩是非常相似的，都能对客户端发来的请求进行处理，它们的区别如下： 作用域不同 过滤器依赖于servlet容器，只能在 servlet容器，web环境下使用拦截器依赖于spring容器，可以在spring容器中调用，不管此时Spring处于什么环境 细粒度的不同 过滤器的控制比较粗，只能在请求进来时进行处理，对请求和响应进行包装拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，也可以在渲染视图呈现给用户之后调用 中断链执行的难易程度不同 拦截器可以 preHandle方法内返回 false 进行中断过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面","categories":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/categories/springBoot/"}],"tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/tags/springBoot/"},{"name":"filter","slug":"filter","permalink":"https://kkzhanga.github.io/tags/filter/"},{"name":"interceptor","slug":"interceptor","permalink":"https://kkzhanga.github.io/tags/interceptor/"}]},{"title":"从零搭建sprinCloud框架（三）","slug":"springCloud/buildSprinCloud_3","date":"2020-11-27T06:16:20.000Z","updated":"2020-12-10T09:44:58.124Z","comments":true,"path":"2020/11/27/springCloud/buildSprinCloud_3/","link":"","permalink":"https://kkzhanga.github.io/2020/11/27/springCloud/buildSprinCloud_3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"从零搭建sprinCloud框架（二）","slug":"springCloud/buildSprinCloud_2","date":"2020-11-26T06:16:20.000Z","updated":"2020-12-10T10:40:47.746Z","comments":true,"path":"2020/11/26/springCloud/buildSprinCloud_2/","link":"","permalink":"https://kkzhanga.github.io/2020/11/26/springCloud/buildSprinCloud_2/","excerpt":"整合gateway简介SpringCloud Gateway成为SpringCloud的重要组件是为了提到替代Netflix Zuul(1.x版本基于过滤器，阻塞IO，不支持长连接，2.x版本一直跳票，2019年5月，开源了支持异步调用模式的Zuul 2.0版本)","text":"整合gateway简介SpringCloud Gateway成为SpringCloud的重要组件是为了提到替代Netflix Zuul(1.x版本基于过滤器，阻塞IO，不支持长连接，2.x版本一直跳票，2019年5月，开源了支持异步调用模式的Zuul 2.0版本) 功能 动态路由 限流 跨域 鉴权，黑白名单机制 日志记录 动态路由Gateway与Eureka整合原理：网关根据serviceId自动从注册中心获取服务地址并转发请求 新建eureka微服务： YML 123456789101112131415#当前服务名称spring: application: name: eureka-service#端口,路径server: port: 10002eureka: client: register-with-eureka: false #自身 不在向eureka注册 fetch-registry: false #启动时禁用client的注册 service-url: defaultZone: http://localhost:10002/eureka POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; Java 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaApp&#123; public static void main( String[] args ) &#123; SpringApplication.run(EurekaApp.class,args); &#125;&#125; 新建gateway微服务： YML 12345678910111213141516171819202122232425#当前服务名称spring: application: name: gateway-server cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后#端口,路径server: port: 11111# 配置 Eureka Server 注册中心eureka: client: service-url: defaultZone: http://localhost:10002/eureka XML 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; Java 123456789@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApp&#123; public static void main( String[] args ) &#123; SpringApplication.run(GatewayApp.class,args); &#125;&#125; 新建order微服务： 根据上面示例创建两个端口不同，名称一致的微服务提供者，模拟集群多示例（略）。 验证 打开eureka控制台我们就可以看到order已经有了两个实例，通过多次点击查询，返回不同实例值。证明达到了负载均衡的效果(eureka集成了ribbon，默认使用的负载均衡策略是轮询，待后续研究) 限流限流背景 业务发展迅速 恶意请求，瞬间并发 限流规则 依赖： POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 限流参数： YML 123456789101112131415161718192021222324spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - name: RequestRateLimiter # 限流过滤器 args: redis-rate-limiter.replenishRate: 1 # 令牌桶每秒填充速率 redis-rate-limiter.burstCapacity: 2 # 令牌桶总容量 key-resolver: &quot;#&#123;@pathKeyResolver&#125;&quot; # 使用 SpEL 表达式按名称引用 bean filter名称必须是RequestRateLimiter redis-rate-limiter.replenishRate：允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity：令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver：使用SpEL按名称引用bean IP限流 Java 1234@Beanpublic KeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&#125; 接口限流 Java 123456@Bean public KeyResolver pathKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath()); &#125; &lt;details&gt; &lt;summary&gt;Java&lt;/summary&gt; 参数限流 Java 1234@Bean public KeyResolver parameterKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;userId&quot;)); &#125; 调试浏览器中对此点击进行接口测试，Redis中会有对应的数据： timestamp:存储的是当前时间的秒数，也就是System.currentTimeMillis() / 1000或者Instant.now().getEpochSecond() tokens:存储的是当前这秒钟的对应的可用的令牌数量 注意事项限流是根据每秒处理数，redis中数据存留的时间只有一秒钟，如果你不快点看redis中是否有数据的话，就看不到了 过滤器Spring Cloud Gateway 根据作用范围划分为 GatewayFilter(局部) 和 GlobalFilter(全局)，二者区别如下： GatewayFilter：局部过滤器，需要通过 spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过 spring.cloud.default-filters 配置在全局，作用在所有路由上。 GlobalFilter：全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过 GatewayFilterAdapter 包装成 GatewayFilterChain 可识别的过滤器，它为请求业务以及路由的 URI 转换为真实业务服务请求地址的核心过滤器，不需要配置系统初始化时加载，并作用在每个路由上。 局部过滤器网关过滤器用于拦截并链式处理 Web 请求，可以实现横切与应用无关的需求，比如：安全、访问超时的设置等。修改传入的 HTTP 请求或传出 HTTP 响应。Spring Cloud Gateway 包含许多内置的网关过滤器工厂一共有 22 个，包括头部过滤器、 路径类过滤器、Hystrix 过滤器和重写请求 URL 的过滤器， 还有参数和状态码等其他类型的过滤器。根据过滤器工厂的用途来划分，可以分为以下几种：Header、Parameter、Path、Body、Status、Session、Redirect、Retry、RateLimiter 和 Hystrix。 我们举个例子说明如何使用 Path路径过滤器 StripPrefixGatewayFilterFactory YML 1234567891011121314151617181920spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 自定义局部过滤器1、继承GatewayFilter，实现后使用java方式配置路由； 2、继承AbstractGatewayFilterFactory，注入为bean即可（推荐） 自定义局部过滤器，并且加入到过滤器工厂，注册到spring容器中 Java 12345678910111213141516171819202122232425public class PartGatewayFilter implements GatewayFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;自定义局部过滤器执行。。。&quot;); return chain.filter(exchange); &#125; /** * 过滤器执行顺序，数值越小，优先级越高 * @return */ @Override public int getOrder() &#123; return 0; &#125;&#125;@Componentpublic class PartGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt; &#123; @Override public GatewayFilter apply(Object config) &#123; return new PartGatewayFilter(); &#125;&#125; YML 123456789101112131415161718192021spring: application: name: gateway-server redis: host: 47.102.104.200 # Redis服务器地址 port: 6379 # Redis服务器端口 #password: admin # Redis服务器密码 cloud: gateway: discovery: # 是否与服务发现组件进行结合，通过 serviceId 转发到具体服务实例。 locator: enabled: true # 是否开启基于服务发现的路由规则 lower-case-service-id: true # 是否将服务名称转小写 routes: # 路由规则 - id: order-service # 路由 ID，唯一 uri: lb://order-service # 目标 URI，路由到微服务的地址 predicates: # 断言（判断条件） - Path=/order/** # 匹配对应 URL 的请求，将匹配到的请求追加在目标 URI 之后 filters: # 网关过滤器 - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 - Part #自定义局部过滤器(配置名称取GatewayFilter前字符串) 自定义局部过滤器 - 指定IP访问我们的需求是如果在配置文件配置了一个IP，那么该ip就可以访问，其它IP通通不能访问。如果不使用该过滤器，那么所有IP都可以访问服务。 这里我们看到上面的PartGatewayFilter和PartGatewayFilterFactory代码本来就是为了同一个过滤器规则编写的两个类，如果过滤器规则很多，那么类文件就很多，其实这两个类可以合并成一个类： Java 1234567891011121314151617181920212223242526272829303132333435@Component@Order(Ordered.LOWEST_PRECEDENCE)public class IPForbidGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;IPForbidGatewayFilterFactory.Config&gt; &#123; public IPForbidGatewayFilterFactory() &#123; super(Config.class); &#125; @Override public List&lt;String&gt; shortcutFieldOrder() &#123; //集合中数据对应Config对象中属性,yml文件中IPForbid带的参数会映射上去,多个参数以逗号隔开 return Arrays.asList(&quot;ip&quot;); &#125; @Override public GatewayFilter apply(Config config) &#123; return (exchange, chain) -&gt; &#123; String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress(); if (config.ip.equals(ip)) &#123; return chain.filter(exchange); &#125; exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); return exchange.getResponse().setComplete(); &#125;; &#125; @Data static public class Config &#123; private String ip; &#125;&#125; YML 1234filters: # 网关过滤器 # - StripPrefix=1 # 将 /api/order/1 重写为 /order/1 - Part #自定义局部过滤器(配置名称取GatewayFilter前字符串) - IPForbid=0:0:0:0:0:0:0:1 全局过滤器实现 GlobalFilter 和 Ordered，重写相关方法，加入到spring容器管理即可，无需配置，全局过滤器对所有的路由都有效。 自定义全局过滤器 接口 Java 123456789101112131415161718192021@Componentpublic class WholeGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;自定义全局过滤器执行。。。&quot;); //调用请求之前统计时间 Long startTime = System.currentTimeMillis(); return chain.filter(exchange).then().then(Mono.fromRunnable(() -&gt; &#123; //调用请求之后统计时间 Long endTime = System.currentTimeMillis(); System.out.println( exchange.getRequest().getURI().getRawPath() + &quot;, 请求耗时 : &quot; + (endTime - startTime) + &quot;ms&quot;); &#125;)); // 继续向下执行 &#125; @Override public int getOrder() &#123; return 1; &#125;&#125; 配置 Java 123456789101112131415161718@Configurationpublic class WholeGlobalFilter &#123; @Bean @Order(1) public GlobalFilter elapsedGlobalFilter() &#123; return (exchange, chain) -&gt; &#123; //调用请求之前统计时间 Long startTime = System.currentTimeMillis(); return chain.filter(exchange).then().then(Mono.fromRunnable(() -&gt; &#123; //调用请求之后统计时间 Long endTime = System.currentTimeMillis(); System.out.println( exchange.getRequest().getURI().getRawPath() + &quot;, 请求耗时 : &quot; + (endTime - startTime) + &quot;ms&quot;); &#125;)); &#125;; &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"从零搭建sprinCloud框架（一）","slug":"springCloud/buildSprinCloud_1","date":"2020-11-19T08:43:07.000Z","updated":"2020-12-10T08:16:04.115Z","comments":true,"path":"2020/11/19/springCloud/buildSprinCloud_1/","link":"","permalink":"https://kkzhanga.github.io/2020/11/19/springCloud/buildSprinCloud_1/","excerpt":"搭建工程基础框架项目父工程配置Idea创建工程： File -&gt; New -&gt; Project","text":"搭建工程基础框架项目父工程配置Idea创建工程： File -&gt; New -&gt; Project Empty Project -&gt;Next 项目命名 -&gt; 项目位置-&gt; Finish 选择打开新窗口 项目子工程配置配置Maven File -&gt; Settings -&gt; OK 新建Module文件 项目上右击 -&gt; New -&gt; Module 选择java -&gt; Next 设置中台模块名称 其他同级模块新建同理，比如前台，docs，sql等，最终呈现如图所示： 新建maven项目 项目上右击(如middle) -&gt; New -&gt; Module -&gt; Maven -&gt; quickstart -&gt;Next 设置ArtifactId，groupId为组织名，一般为公司网址反写 -&gt; Next 设置工程名称(在根目录下新加同名子文件夹) -&gt; Finish 创建resources文件夹: 右击main -&gt; New -&gt; Directory 右击resources, 变成有黄色的横杠,作为资源根目录","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/tags/SpringCloud/"},{"name":"maven","slug":"maven","permalink":"https://kkzhanga.github.io/tags/maven/"},{"name":"idea","slug":"idea","permalink":"https://kkzhanga.github.io/tags/idea/"}]}],"categories":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/categories/springBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/categories/SpringCloud/"}],"tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://kkzhanga.github.io/tags/springBoot/"},{"name":"filter","slug":"filter","permalink":"https://kkzhanga.github.io/tags/filter/"},{"name":"interceptor","slug":"interceptor","permalink":"https://kkzhanga.github.io/tags/interceptor/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://kkzhanga.github.io/tags/SpringCloud/"},{"name":"maven","slug":"maven","permalink":"https://kkzhanga.github.io/tags/maven/"},{"name":"idea","slug":"idea","permalink":"https://kkzhanga.github.io/tags/idea/"}]}